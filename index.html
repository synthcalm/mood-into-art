<script>
// Audio Context and Recording Variables
let audioContext;
let mediaRecorder;
let audioChunks = [];
let isRecording = false;
let countdownInterval;
const MAX_RECORD_TIME = 30 * 60; // 30 minutes in seconds

// DOM Elements
const startVoiceButton = document.getElementById('startVoice');
const redoButton = document.getElementById('redo');
const generateButton = document.getElementById('generate');
const saveButton = document.getElementById('saveImage');
const activityInput = document.getElementById('activityInput');
const styleSelect = document.getElementById('styleSelect');
const waveformCanvas = document.getElementById('waveform');
const dateDisplay = document.getElementById('dateDisplay');
const countdownDisplay = document.getElementById('countdownDisplay');
const redDot = document.getElementById('redDot');

// Initialize Canvas
const canvasCtx = waveformCanvas.getContext('2d');
waveformCanvas.width = waveformCanvas.offsetWidth;
waveformCanvas.height = waveformCanvas.offsetHeight;

// Audio Visualization
function drawWaveform() {
    if (!isRecording) return;
    
    const analyzer = audioContext.createAnalyser();
    const source = audioContext.createMediaStreamSource(mediaRecorder.stream);
    source.connect(analyzer);
    
    analyzer.fftSize = 2048;
    const bufferLength = analyzer.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);

    function draw() {
        canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        canvasCtx.fillRect(0, 0, waveformCanvas.width, waveformCanvas.height);
        
        analyzer.getByteTimeDomainData(dataArray);
        canvasCtx.lineWidth = 2;
        canvasCtx.strokeStyle = '#00FFFF';
        canvasCtx.beginPath();

        const sliceWidth = waveformCanvas.width * 1.0 / bufferLength;
        let x = 0;

        for (let i = 0; i < bufferLength; i++) {
            const v = dataArray[i] / 128.0;
            const y = v * waveformCanvas.height / 2;
            
            if (i === 0) canvasCtx.moveTo(x, y);
            else canvasCtx.lineTo(x, y);
            
            x += sliceWidth;
        }

        canvasCtx.lineTo(waveformCanvas.width, waveformCanvas.height/2);
        canvasCtx.stroke();
        requestAnimationFrame(draw);
    }
    draw();
}

// Audio Handling
async function startRecording() {
    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream);
        
        mediaRecorder.ondataavailable = event => {
            audioChunks.push(event.data);
        };
        
        mediaRecorder.onstop = () => {
            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
            // Here you would handle the audio blob (upload to server, etc)
        };

        mediaRecorder.start();
        isRecording = true;
        startVoiceButton.classList.add('recording');
        redDot.style.display = 'block';
        drawWaveform();
        startCountdown();
    } catch (err) {
        console.error('Recording failed:', err);
        alert('Microphone access required! Please allow audio permissions.');
    }
}

function stopRecording() {
    if (mediaRecorder && isRecording) {
        mediaRecorder.stop();
        isRecording = false;
        startVoiceButton.classList.remove('recording');
        redDot.style.display = 'none';
        clearInterval(countdownInterval);
        document.getElementById('chimeSound').play();
    }
}

// Countdown Timer
function startCountdown() {
    let secondsRemaining = MAX_RECORD_TIME;
    
    countdownInterval = setInterval(() => {
        if (secondsRemaining <= 0) {
            stopRecording();
            return;
        }
        
        const minutes = Math.floor(secondsRemaining / 60);
        const seconds = secondsRemaining % 60;
        countdownDisplay.textContent = 
            `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        secondsRemaining--;
    }, 1000);
}

// Event Listeners
startVoiceButton.addEventListener('click', () => {
    if (!isRecording) {
        startRecording();
    } else {
        stopRecording();
    }
});

redoButton.addEventListener('click', () => {
    activityInput.value = '';
    styleSelect.value = 'none';
    document.getElementById('generatedImage').style.display = 'none';
});

generateButton.addEventListener('click', async () => {
    if (!activityInput.value.trim() || styleSelect.value === 'none') {
        alert('Please describe your mood and select a style!');
        return;
    }

    const loadingIndicator = document.getElementById('loadingIndicator');
    loadingIndicator.style.display = 'flex';
    
    try {
        // Simulated API call - replace with actual endpoint
        const response = await fetch('YOUR_API_ENDPOINT', {
            method: 'POST',
            body: JSON.stringify({
                prompt: activityInput.value,
                style: styleSelect.value
            })
        });
        
        const imageUrl = await response.json();
        const generatedImage = document.getElementById('generatedImage');
        generatedImage.src = imageUrl;
        generatedImage.style.display = 'block';
        document.getElementById('beepSound').play();
    } catch (error) {
        console.error('Generation failed:', error);
        alert('Image generation failed. Please try again.');
    } finally {
        loadingIndicator.style.display = 'none';
    }
});

saveButton.addEventListener('click', () => {
    const image = document.getElementById('generatedImage');
    if (!image.src) {
        alert('No image to save!');
        return;
    }
    
    const link = document.createElement('a');
    link.download = 'mood-art.png';
    link.href = image.src;
    link.click();
    document.getElementById('saveSound').play();
});

// Initialize Date Display
dateDisplay.textContent = new Date().toLocaleDateString('en-US', {
    weekday: 'long', 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric'
});

// Initial Grid Drawing
function drawInitialGrid() {
    canvasCtx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
    canvasCtx.lineWidth = 1;
    
    // Horizontal lines
    for(let y = 0; y < waveformCanvas.height; y += 20) {
        canvasCtx.beginPath();
        canvasCtx.moveTo(0, y);
        canvasCtx.lineTo(waveformCanvas.width, y);
        canvasCtx.stroke();
    }
    
    // Vertical lines
    for(let x = 0; x < waveformCanvas.width; x += 20) {
        canvasCtx.beginPath();
        canvasCtx.moveTo(x, 0);
        canvasCtx.lineTo(x, waveformCanvas.height);
        canvasCtx.stroke();
    }
}
drawInitialGrid();
</script>
