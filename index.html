<script>
    const grid = document.getElementById('grid');
    const gridCtx = grid.getContext('2d');
    function drawGrid() {
        grid.width = grid.clientWidth;
        grid.height = grid.clientHeight;
        const w = grid.width;
        const h = grid.height;
        gridCtx.clearRect(0, 0, w, h);
        gridCtx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
        gridCtx.lineWidth = 0.3;
        for (let i = 0; i <= w; i += w / 20) {
            gridCtx.beginPath();
            gridCtx.moveTo(i, 0);
            gridCtx.lineTo(i, h);
            gridCtx.stroke();
        }
        for (let j = 0; j <= h; j += h / 12) {
            gridCtx.beginPath();
            gridCtx.moveTo(0, j);
            gridCtx.lineTo(w, j);
            gridCtx.stroke();
        }
        gridCtx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
        gridCtx.lineWidth = 0.5;
        gridCtx.beginPath();
        gridCtx.moveTo(0, h / 2);
        gridCtx.lineTo(w, h / 2);
        gridCtx.stroke();
    }
    window.addEventListener('load', drawGrid);
    window.addEventListener('resize', drawGrid);

    const startBtn = document.getElementById('startVoice');
    const generateBtn = document.getElementById('generate');
    const redDot = document.getElementById('redDot');
    const waveform = document.getElementById('waveform');
    const waveformCtx = waveform.getContext('2d');
    const loadingIndicator = document.getElementById('loadingIndicator');
    const generatedImage = document.getElementById('generatedImage');
    let audioContext, analyser, dataArray, source, animationId, recognition, isRecording = false;

    async function startMic() {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        dataArray = new Uint8Array(analyser.fftSize);
        source.connect(analyser);
        drawWaveform();
    }
    function drawWaveform() {
        waveform.width = waveform.clientWidth;
        waveform.height = waveform.clientHeight;
        waveformCtx.clearRect(0, 0, waveform.width, waveform.height);
        analyser.getByteTimeDomainData(dataArray);
        waveformCtx.strokeStyle = 'cyan';
        waveformCtx.lineWidth = 1;
        waveformCtx.beginPath();
        let sliceWidth = waveform.width / dataArray.length;
        let x = 0;
        for (let i = 0; i < dataArray.length; i++) {
            let v = dataArray[i] / 128.0;
            let y = v * waveform.height / 2;
            if (i === 0) waveformCtx.moveTo(x, y);
            else waveformCtx.lineTo(x, y);
            x += sliceWidth;
        }
        waveformCtx.lineTo(waveform.width, waveform.height / 2);
        waveformCtx.stroke();
        animationId = requestAnimationFrame(drawWaveform);
    }
    function startSpeech() {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) return alert('Speech recognition not supported');
        recognition = new SpeechRecognition();
        recognition.continuous = true;
        recognition.interimResults = true;
        recognition.lang = 'en-US';
        const input = document.getElementById('activityInput');
        recognition.onresult = e => {
            let transcript = '';
            for (let i = 0; i < e.results.length; i++) {
                transcript += e.results[i][0].transcript + ' ';
            }
            input.value = transcript;
        };
        recognition.start();
    }
    startBtn.addEventListener('click', async () => {
        if (!isRecording) {
            await startMic();
            startSpeech();
            redDot.style.display = 'block';
            startBtn.textContent = 'Stop Voice';
            isRecording = true;
        } else {
            recognition.stop();
            audioContext.close();
            cancelAnimationFrame(animationId);
            redDot.style.display = 'none';
            startBtn.textContent = 'Start Voice';
            isRecording = false;
        }
    });

    // DALL-E Integration for Generate Image
    generateBtn.addEventListener('click', async () => {
        const activityInput = document.getElementById('activityInput').value;
        const styleSelect = document.getElementById('styleSelect').value;

        if (!activityInput || activityInput === '[No speech recognized]') {
            alert('Please provide some text to generate an image.');
            return;
        }

        loadingIndicator.style.display = 'block';
        generatedImage.style.display = 'none';

        try {
            // Construct prompt with style
            const prompt = `${activityInput} in ${styleSelect} style`;

            const response = await fetch('https://api.openai.com/v1/images/generations', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer YOUR_API_KEY_HERE' // Replace with your OpenAI API key
                },
                body: JSON.stringify({
                    prompt: prompt,
                    n: 1, // Number of images to generate
                    size: '512x512' // DALL-E supported sizes: 256x256, 512x512, 1024x1024
                })
            });

            if (!response.ok) {
                throw new Error(`API error: ${response.statusText}`);
            }

            const data = await response.json();
            if (data.data && data.data[0] && data.data[0].url) {
                generatedImage.src = data.data[0].url; // Set the generated image URL
                generatedImage.style.display = 'block';
                loadingIndicator.style.display = 'none';

                // Log to mood history
                const logHistory = document.getElementById('logHistory');
                const timestamp = new Date().toLocaleString();
                logHistory.innerHTML += `<p>${timestamp}: "${activityInput}" in ${styleSelect} style</p>`;
            } else {
                throw new Error('No image URL returned from DALL-E');
            }
        } catch (error) {
            alert('Failed to generate image: ' + error.message);
            loadingIndicator.style.display = 'none';
        }
    });
</script>
